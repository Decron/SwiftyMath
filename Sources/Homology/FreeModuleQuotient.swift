//
//  FreeModuleQuotient.swift
//  SwiftyAlgebra
//
//  Created by Taketo Sano on 2017/05/14.
//  Copyright © 2017年 Taketo Sano. All rights reserved.
//

import Foundation


public enum FreeModuleQuotientGenerator<A: FreeModuleBase, R: Ring>: CustomStringConvertible {
    case Free(generator: FreeModule<A, R>)
    case Tor(factor: R, generator: FreeModule<A, R>)
    
    public var isFree: Bool {
        switch self{
        case .Free(_)  : return true
        case .Tor(_, _): return false
        }
    }
    
    public var generator: FreeModule<A, R> {
        switch self{
        case let .Free(g)  : return g
        case let .Tor(_, g): return g
        }
    }
    
    public var description: String {
        let name = (R.self == IntegerNumber.self) ? "Z" : "\(R.self)"
        switch self{
        case .Free(_): return name
        case let .Tor(f, _): return "\(name)/\(f)"
        }
    }
}

public struct FreeModuleQuotient<A: FreeModuleBase, R: Ring>: CustomStringConvertible {
    public let generators: [FreeModuleQuotientGenerator<A, R>]
    
    public init(_ generators: [FreeModuleQuotientGenerator<A, R>]) {
        self.generators = generators
    }
    
    public var description: String {
        let desc = generators.map{$0.description}.joined(separator: "⊕")
        return desc.isEmpty ? "0" : desc
    }
}

public extension FreeModuleQuotient where R: EuclideanRing {
    
    // This struct represents the quotient module M/N.
    // We identify a matrix M with the module generated by (basis * M).
    // The given N must be a submod of M, so in particular l <= k must hold.
    
    public init<n:_Int, k:_Int, l:_Int>(basis: [A], divident M: Matrix<R, n, k>, divisor N: Matrix<R, n, l>) {
        let rankM = M.cols // == k
        let rankN = N.cols // == l
        
        // Find P such that N = MP, then N is the image of M by P.
        // With the left-elimination on M as LM = [D; 0], LN = LMP = [DP; 0].
        // LN must be divisible by each diagonal factor of D.
        
        let P : Matrix<R, k, l> = {
            let E = MatrixElimination(M, mode: .RowsOnly)
            let L:  Matrix<R, n, n> = E.left
            let D:  Matrix<R, k, k> = (L * M).submatrix(rowsInRange: 0 ..< rankM)
            let DP: Matrix<R, k, l> = (L * N).submatrix(rowsInRange: 0 ..< rankM)
            return  Matrix<R, k, l>(rows: rankM, cols: rankN) { (i, j) in
                let a = D[i, i]
                let (q, r) = DP[i, j] /% a
                
                guard r == 0 else {
                    fatalError("N is not a submodule of M.")
                }
                
                return q
            }
        }()
        
        // Now let P' = QPR, where P' = [D'; 0].
        // Then
        //
        //   NR = MPR
        //      = TP'  (where T := M Q^-1)
        //
        // By taking new bases T and NR on M, N resp.,
        // the map from M to N simply becomes P'.
        // Thus we can easily find the generators of the quotient module.
        //
        // ex) P' = [ diag(1, 1, 2); O_3 ]
        //        => M/N = Z/2 + Z^3.
        
        let (T, d): (Matrix<R, n, k>, [R]) = {
            let E = MatrixElimination(P)
            return (M * E.leftInverse, E.diagonal)
        }()
        
        typealias FM = FreeModule<A, R>
        
        let freePart: [FreeModuleQuotientGenerator] = (rankN ..< rankM).map { j in
            .Free(generator: FM(basis: basis, values: T.colArray(j)))
        }
        
        let torPart: [FreeModuleQuotientGenerator]  = d.enumerated()
            .filter{ (j, a) in a != R.identity }
            .map { (j, a) in
                .Tor(factor: a, generator: FM(basis: basis, values: T.colArray(j)))
        }
        
        self.init(freePart + torPart)
    }
}

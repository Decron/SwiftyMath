//
//  FreeModuleQuotient.swift
//  SwiftyAlgebra
//
//  Created by Taketo Sano on 2017/05/14.
//  Copyright © 2017年 Taketo Sano. All rights reserved.
//

import Foundation


public enum FreeModuleQuotientGenerator<A: FreeModuleBase, R: Ring>: CustomStringConvertible {
    case Free(generator: FreeModule<A, R>)
    case Tor(factor: R, generator: FreeModule<A, R>)
    
    public var isFree: Bool {
        switch self{
        case .Free(_)  : return true
        case .Tor(_, _): return false
        }
    }
    
    public var generator: FreeModule<A, R> {
        switch self{
        case let .Free(g)  : return g
        case let .Tor(_, g): return g
        }
    }
    
    public var description: String {
        let name = (R.self == IntegerNumber.self) ? "Z" : "\(R.self)"
        switch self{
        case .Free(_): return name
        case let .Tor(f, _): return "\(name)/\(f)"
        }
    }
}

public struct FreeModuleQuotient<A: FreeModuleBase, R: Ring>: CustomStringConvertible {
    public let generators: [FreeModuleQuotientGenerator<A, R>]
    
    public init(_ generators: [FreeModuleQuotientGenerator<A, R>]) {
        self.generators = generators
    }
    
    public var description: String {
        let desc = generators.map{$0.description}.joined(separator: "⊕")
        return desc.isEmpty ? "0" : desc
    }
}

public extension FreeModuleQuotient where R: EuclideanRing {
    
    private typealias FM = FreeModule<A, R>
    
    // This struct represents the quotient module M/N.
    // We identify a matrix M with the module generated by (basis * M).
    // The given N must be a submod of M, so in particular l <= k must hold.
    
    public init<n:_Int, k:_Int, l:_Int>(basis: [A], divident M: Matrix<R, n, k>, divisor N: Matrix<R, n, l>) {
        
        // First calculate P such that N = MP, then N is the image of M by P.
        // Let P' = QPR, where P' = [D; 0] is the rank-normal-form. 
        //
        //   NR = MPR
        //      = TP'  (where T := M Q^-1)
        //
        // By taking new bases T on M, the map from M to N becomes P'.
        // We can easily find the generators of the quotient module.
        //
        // ex) P' = [ diag(1, 1, 2); O_3 ]
        //        => M/N = Z/2 + Z^3.
        
        let (k, l) = (M.cols, N.cols)
        
        let P: Matrix<R, k, l> = FreeModuleQuotient.calculateP(M, N)
        let e = P.eliminate()
        
        let T: Matrix<R, n, k>  = M * e.leftInverse
        let diag: [R] = e.diagonal
        
        let freePart: [FreeModuleQuotientGenerator] = (l ..< k).map { j in
            .Free(generator: FM(basis: basis, values: T.colArray(j)))
        }
        
        let torPart: [FreeModuleQuotientGenerator]  = diag.enumerated()
            .filter{ (j, a) in a != R.identity }
            .map { (j, a) in
                .Tor(factor: a, generator: FM(basis: basis, values: T.colArray(j)))
        }
        
        self.init(freePart + torPart)
    }
    
    private static func calculateP<n:_Int, k:_Int, l:_Int>(_ M: Matrix<R, n, k>, _ N: Matrix<R, n, l>) -> Matrix<R, k, l> {
        // With the left-elimination on M as LM = [D; 0], LN = LMP = [DP; 0].
        // LN must be divisible by each diagonal factor of D.
        
        let (k, l) = (M.cols, N.cols)
        
        let L : Matrix<R, n, n> = M.eliminate(mode: .Rows).left
        let D : Matrix<R, k, k> = (L * M).submatrix(rowsInRange: 0 ..< k)
        let DP: Matrix<R, k, l> = (L * N).submatrix(rowsInRange: 0 ..< k)
        
        return  Matrix<R, k, l>(rows: k, cols: l) { (i, j) in
            let a = D[i, i]
            let (q, r) = DP[i, j] /% a
            
            guard r == 0 else {
                fatalError("N is not a submodule of M.")
            }
            
            return q
        }
    }
}
